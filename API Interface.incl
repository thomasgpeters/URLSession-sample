// 20230705// Thomas Peters// Playing with URLSession// CFMutableStringRef appServiceUser   = fn MutableStringNew// CFMutableStringRef appServicePasswd = fn MutableStringNewlocal fn ProcessTasks( session as URLSessionRef, tasks as CFArrayRef, userData as ptr )'~'1URLSessionDataTaskRef     task =  fn ArrayFirstObject( tasks )ProgressRef           progress =  fn URLSessionTaskProgress( task )NSLog( @"Expected bytes: %llu\n", fn URLSessionTaskCountOfBytesClientExpectsToSend( task ) )NSLog( @"Operation kind: %@\n",   fn ProgressFileOperationKind( progress ) )NSLog( @"URL: %@\n",              fn ProgressFileURL( progress ) )end fnvoid local fn URLSessionHandler( session as URLSessionRef, dta as CFDataRef, response as URLResponseRef, err as ErrorRef, userData as ptr )'~'1block CFStringRef				tempblock CFTypeRef					elementblock CFMutableStringRef parsedStrblock CFTypeRef					jsonObjectblock CFDictionaryRef		jsonDictionarydispatchglobalErrorRef  jsonErr = NULLNSInteger statusCodecln statusCode = [(NSHTTPURLResponse *)response statusCode];if ( statusCode == 200 )parsedStr  = fn MutableStringNewjsonObject = fn JSONSerializationJSONObjectWithData( dta, NSJSONReadingMutableContainers + NSJSONReadingMutableLeaves, @jsonErr )if ( jsonErr == NULL )MutableStringAppendString( parsedStr, (CFStringRef)@"\nJSON dictionary has these Keys and Values:\n\n")jsonDictionary = (CFDictionaryRef)jsonObjectfor element in jsonDictionarytemp = fn StringWithFormat( @"Key: %@\n\tValue: %@\n\n", fn ObjectDescription( element ), fn DictionaryValueForKey( jsonDictionary, fn ObjectDescription( element ) ) )MutableStringAppendString( parsedStr, (CFStringRef)temp )nextNSLog( @"%@", parsedStr )end ifelseNSLog( @"%@", fn ErrorLocalizedDescription( err ) )end ifdispatchendend fnvoid local fn URLSessionWithGetRequest( path as CFStringRef )'~'1MutableURLRequestRef		urlRequestCFURLRef 							urlURLSessionRef					sessionURLSessionDataTaskRef	taskurl = fn URLWithString( path )// cln urlRequest = (MutableURLRequestRef)[[NSMutableURLRequest alloc] initWithURL:(NSURL *)url];  // Coming in FB 7.0.22: toolbox fn MutableURLRequestWithURL( CFURLRef url ) = MutableURLRequestRefurlRequest = fn MutableURLRequestWithURL( url )MutableURLRequestSetHTTPMethod( urlRequest, @"GET" )session = fn URLSessionSharedSessiontask = fn URLSessionDataTaskWithRequestCompletionHandler( session, urlRequest, @fn URLSessionHandler, NULL )URLSessionTaskResume( task )end fnlocal fn ProcessTasks2( session as URLSessionRef, tasks as CFArrayRef, userData as ptr )'~'1URLSessionDataTaskRef     task = fn ArrayFirstObject( tasks )ProgressRef           progress = fn URLSessionTaskProgress( task )TextSetString(        _textView, fn StringWithFormat( @"Expected bytes: %llu\n", fn URLSessionTaskCountOfBytesClientExpectsToSend( task ) ) )TextViewAppendString( _textView, fn StringWithFormat( @"Operation kind: %@\n",   fn ProgressFileOperationKind(      progress ) ) )TextViewAppendString( _textView, fn StringWithFormat( @"URL: %@\n",              fn ProgressFileURL(                progress ) ) )end fnlocal fn URLSessionHandler2( session as URLSessionRef, dta as CFDataRef, response as URLResponseRef, err as ErrorRef, userData as ptr )'~'1if fn StringIsEqual( fn StringWithData( dta, NSUTF8StringEncoding ), @"") == NOTextViewAppendString( _textView, fn StringWithFormat( @"Data: %@\n", dta ) )TextViewAppendString( _textView, fn StringWithFormat( @"\nPLEASE WAIT. Data downloading:\n\n", dta ) )dispatchmaindispatchmainTextViewAppendString( _textView, fn StringWithData( dta, NSUTF8StringEncoding ) )dispatchenddispatchendScrollViewScrollToTop( _scrollView )NSLog( @"Expected content length: %d",         fn URLResponseExpectedContentLength( response ) )NSLog( @"Suggested file name: %@",             fn URLResponseSuggestedFilename(     response ) )NSLog( @"MIME type for this session: %@",      fn URLResponseMIMEType(              response ) )NSLog( @"Encoding for received text: %@",      fn URLResponseTextEncodingName(      response ) )NSLog( @"URL of file data being received: %@", fn URLResponseURL(                   response ) )NSLog( @"User data: %@", (CFStringRef)userData )elseNSLog( @"Error data: %@", fn ErrorLocalizedDescription( err ) )end ifURLSessionFinishTasksAndInvalidate( session )end fnvoid local fn GetAPIContent( path as CFStringRef )'~'1/*// stores host in global variable and// appends path to urlStr so can easily// change host when server is moved*/ErrorRef  jsonErr = NULLCFStringRef urlStr = fn StringByAppendingString(host, path )CFURLRef urlURLSessionConfigurationRef 	configCFMutableDictionaryRef			requestHeadersCFStringRef								bearerTokenCFDictionaryRef						authDictCFStringRef								theTokenOperationQueueRef					queueURLSessionRef							sessionURLSessionDataTaskRef			task// CFURLRef url = fn URLWithString( fn StringByAppendingString(urlStr, @"?include=OrderList&fields%5BCustomer%5D=Id%2CCompanyName%2CContactName%2CContactTitle%2CAddress%2CCity%2CRegion%2CPostalCode%2CCountry%2CPhone%2CFax%2CBalance%2CCreditLimit%2COrderCount%2CUnpaidOrderCount%2CClient_id" ) )url = fn URLWithString( urlStr )config = fn URLSessionConfigurationDefaultrequestHeaders = fn MutableDictionaryNewMutableDictionarySetValueForKey( requestHeaders, @"application/vnd.api+json",   @"accept" )MutableDictionarySetValueForKey( requestHeaders, @"application/json",           @"Content-Type" )MutableDictionarySetValueForKey( requestHeaders, host,                          @"Host" )if (isSecurityOn)if (authData != NULL)authDict = fn JSONSerializationJSONObjectWithData( authData, 0, @jsonErr )theToken = fn DictionaryValueForKey( authDict, @"access_token" )if (theToken != NULL)bearerToken = fn StringByAppendingString(@"Bearer ", theToken )NSLog( @"Authorization: %@", bearerToken )MutableDictionarySetValueForKey( requestHeaders, bearerToken, @"Authorization" )end ifend ifend if// NSLog( @"Request Headers %@", requestHeaders )URLSessionConfigurationSetHTTPAdditionalHeaders( config, (CFDictionaryRef) requestHeaders )queue = fn OperationQueueInitOperationQueueSetMaxConcurrentOperationCount( queue, NSOperationQueueDefaultMaxConcurrentOperationCount )session = fn URLSessionWithDelegateQueue( config, queue )task = fn URLSessionDataTaskWithURLCompletionHandler( session, url, @fn URLSessionHandler, NULL )URLSessionTaskResume( task )URLSessionGetAllTasksWithCompletionHandler( session, @fn ProcessTasks, NULL )end fnlocal fn URLSessionAuthHandler( session as URLSessionRef, dta as CFDataRef, response as URLResponseRef, err as ErrorRef, userData as ptr )'~'1block ErrorRef  jsonErr = NULLblock NSInteger statusCodedispatchglobalcln statusCode = [(NSHTTPURLResponse *)response statusCode];if ( statusCode == 200 )authData = dtaauthDictionary = fn JSONSerializationJSONObjectWithData( dta, 0, @jsonErr )if ( jsonErr == NULL )// myAuthToken = fn MutableStringNew// MutableStringAppendString( myAuthToken, @"Bearer " )// MutableStringAppendString( myAuthToken, fn DictionaryValueForKey( authDictionary, @"access_token" ) )if (authDictionary != NULL)NSLog( @"\n\nThe access_token from %@ is:\n\"%@\"", fn URLPath( userData ), fn DictionaryObjectForKey( authDictionary, @"access_token" ) )end ifelseNSLog( @"JSON Error : %@", fn ErrorLocalizedDescription( jsonErr ) )end ifelseNSLog( @"ErrorRef : %@", fn ErrorLocalizedDescription( err ) )end ifdispatchendURLSessionFinishTasksAndInvalidate( session )end fnlocal fn URLSessionAuthAPI( path as CFStringRef )'~'1CFDictionaryRef						requestHeadersURLSessionConfigurationRef	configOperationQueueRef					queueURLSessionRef							sessionCFMutableStringRef					urlStrCFURLRef									urlMutableURLRequestRef				requestCFStringRef								jsonStrCFDataRef									jsonBodyURLSessionDataTaskRef			taskrequestHeaders = @{@"Host": host, @"Content-Type":@"application/json",@"accept": @"application/vnd.api+json",@"accept":@"application/vnd.api+json",@"Content-Length":@80}config = fn URLSessionConfigurationDefaultURLSessionConfigurationSetHTTPAdditionalHeaders( config, requestHeaders )queue = fn OperationQueueInitOperationQueueSetMaxConcurrentOperationCount( queue, NSOperationQueueDefaultMaxConcurrentOperationCount )session = fn URLSessionWithDelegateQueue( config, queue )urlStr = fn MutableStringWithString( host )MutableStringAppendString(urlStr, path )url = fn URLWithString( (CFStringRef) urlStr )request = fn MutableURLRequestWithURL( url )// cln request = (MutableURLRequestRef)[[NSMutableURLRequest alloc] initWithURL:(NSURL *)url];jsonStr = @"{¬\"username\": \"admin\",¬\"password\": \"p\"¬}"jsonBody = fn StringData( jsonStr, NSUTF8StringEncoding )MutableURLRequestSetHTTPBody( (MutableURLRequestRef)request, jsonBody )MutableURLRequestSetHTTPMethod( (MutableURLRequestRef)request, @"POST" )task = fn URLSessionDataTaskWithRequestCompletionHandler( session, request, @fn URLSessionAuthHandler, NULL )URLSessionTaskResume( task )end fnvoid local fn ProjectMetadataHandler( session as URLSessionRef, dta as CFDataRef, response as URLResponseRef, err as ErrorRef, userData as ptr )'~'1CFTypeRef							elementCFMutableStringRef			parsedStrCFTypeRef							jsonObjectCFDictionaryRef				jsonDictionary, objectDictionaryRefCFMutableDictionaryRef	projectObjectsDictionaryRefCFArrayRef 						apiResourceKeysArrayRefCFMutableArrayRef			tableArrayErrorRef					jsonErr = NULLcln statusCode = [(NSHTTPURLResponse *)response statusCode];if ( statusCode == 200 )parsedStr  = fn MutableStringNewjsonObject = fn JSONSerializationJSONObjectWithData( dta, NSJSONReadingMutableContainers + NSJSONReadingMutableLeaves, @jsonErr )if ( jsonErr == NULL )jsonDictionary = ( CFDictionaryRef ) jsonObject 																' cast to CFDisctionaryRefglobalProjectDictionary = jsonDictionaryTableViewBeginUpdates( _objectListView )tableArray = fn TableViewData( _objectListView )if ( tableArray != NULL )fn MutableArrayAddObject( tableArray, @"Hello" )fn MutableArrayAddObject( tableArray, @"there" )fn MutableArrayAddObject( tableArray, @"how" )fn MutableArrayAddObject( tableArray, @"are" )fn MutableArrayAddObject( tableArray, @"you?" )NSLog( @"Adding %@ to the table Array.", @"Hello" )elseNSLog( @"Table Array is null - couldn't find it!" )end ifTableViewEndUpdates( _objectListView )TableViewReloadData( _objectListView )' apiResourceKeysArrayRef = ( CFArrayRef ) fn DictionaryAllKeys( jsonDictionary )		' now get the keys in a array' projectObjectsDictionaryRef = ( CFMutableDictionaryRef ) fn DictionaryObjectForKey( globalProjectDictionary, @"objects" )' MutableDictionaryAddEntriesFromDictionary( projectObjectsDictionaryRef, jsonDictionary )/*for element in apiResourceKeysArrayRefobjectDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )MutableDictionarySetValueForKey( objectDictionaryRef, (CFStringRef) element, @"Name" )MutableDictionarySetValueForKey( projectObjectsDictionaryRef, objectDictionaryRef, (CFStringRef) element )next*/if (isLoggingOn)MutableStringAppendString( parsedStr, @"\nJSON dictionary has these Keys and Values:\n\n")for element in jsonDictionaryMutableStringAppendString( parsedStr, fn StringWithFormat( @"Key: %@\n\tValue: %@\n\n", fn ObjectDescription( element ), fn DictionaryValueForKey( jsonDictionary, fn ObjectDescription( element ) ) ) )nextNSLog( @"%@", parsedStr )end ifend ifelseif (isLoggingOn)NSLog( @"%@", fn ErrorLocalizedDescription( err ) )end ifend ifend fnlocal fn ProjectMetadataAPI( path as CFStringRef )'~'1/*// stores host in global variable and// appends path to urlStr so can easily// change host when server is moved*/ErrorRef  jsonErr = NULLCFStringRef urlStr = fn StringByAppendingString(host, path )CFURLRef									urlURLSessionConfigurationRef 	configCFMutableDictionaryRef			requestHeadersCFStringRef								bearerTokenCFDictionaryRef						authDictCFStringRef								theTokenOperationQueueRef 					queueURLSessionRef							sessionURLSessionDataTaskRef			task// CFURLRef url = fn URLWithString( fn StringByAppendingString(urlStr, @"?include=OrderList&fields%5BCustomer%5D=Id%2CCompanyName%2CContactName%2CContactTitle%2CAddress%2CCity%2CRegion%2CPostalCode%2CCountry%2CPhone%2CFax%2CBalance%2CCreditLimit%2COrderCount%2CUnpaidOrderCount%2CClient_id" ) )url = fn URLWithString( urlStr )config = fn URLSessionConfigurationDefaultrequestHeaders = fn MutableDictionaryNewMutableDictionarySetValueForKey( requestHeaders, @"application/vnd.api+json", @"accept" )MutableDictionarySetValueForKey( requestHeaders, @"application/json",         @"Content-Type" )MutableDictionarySetValueForKey( requestHeaders, host,                        @"Host" )if (isSecurityOn)if (authData != NULL)authDict = fn JSONSerializationJSONObjectWithData( authData, 0, @jsonErr )theToken = fn DictionaryValueForKey( authDict, @"access_token" )if (theToken != NULL)bearerToken = fn StringByAppendingString(@"Bearer ", theToken )if (isLoggingOn)NSLog( @"Authorization: %@", bearerToken )end ifMutableDictionarySetValueForKey( requestHeaders, bearerToken, @"Authorization" )end ifend ifend ifURLSessionConfigurationSetHTTPAdditionalHeaders( config, (CFDictionaryRef) requestHeaders )queue = fn OperationQueueInitOperationQueueSetMaxConcurrentOperationCount( queue, NSOperationQueueDefaultMaxConcurrentOperationCount )session = fn URLSessionWithDelegateQueue( config, queue )task = fn URLSessionDataTaskWithURLCompletionHandler( session, url, @fn ProjectMetadataHandler, NULL )URLSessionTaskResume( task )URLSessionGetAllTasksWithCompletionHandler( session, @fn ProcessTasks, NULL )end fn